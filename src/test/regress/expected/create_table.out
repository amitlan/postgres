--
-- CREATE_TABLE
--
--
-- CLASS DEFINITIONS
--
CREATE TABLE hobbies_r (
	name		text,
	person 		text
);
CREATE TABLE equipment_r (
	name 		text,
	hobby		text
);
CREATE TABLE onek (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
) WITH OIDS;
CREATE TABLE tenk2 (
	unique1 	int4,
	unique2 	int4,
	two 	 	int4,
	four 		int4,
	ten			int4,
	twenty 		int4,
	hundred 	int4,
	thousand 	int4,
	twothousand int4,
	fivethous 	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
CREATE TABLE person (
	name 		text,
	age			int4,
	location 	point
);
CREATE TABLE emp (
	salary 		int4,
	manager 	name
) INHERITS (person) WITH OIDS;
CREATE TABLE student (
	gpa 		float8
) INHERITS (person);
CREATE TABLE stud_emp (
	percent 	int4
) INHERITS (emp, student);
NOTICE:  merging multiple inherited definitions of column "name"
NOTICE:  merging multiple inherited definitions of column "age"
NOTICE:  merging multiple inherited definitions of column "location"
CREATE TABLE city (
	name		name,
	location 	box,
	budget 		city_budget
);
CREATE TABLE dept (
	dname		name,
	mgrname 	text
);
CREATE TABLE slow_emp4000 (
	home_base	 box
);
CREATE TABLE fast_emp4000 (
	home_base	 box
);
CREATE TABLE road (
	name		text,
	thepath 	path
);
CREATE TABLE ihighway () INHERITS (road);
CREATE TABLE shighway (
	surface		text
) INHERITS (road);
CREATE TABLE real_city (
	pop			int4,
	cname		text,
	outline 	path
);
--
-- test the "star" operators a bit more thoroughly -- this time,
-- throw in lots of NULL fields...
--
-- a is the type root
-- b and c inherit from a (one-level single inheritance)
-- d inherits from b and c (two-level multiple inheritance)
-- e inherits from c (two-level single inheritance)
-- f inherits from e (three-level single inheritance)
--
CREATE TABLE a_star (
	class		char,
	a 			int4
);
CREATE TABLE b_star (
	b 			text
) INHERITS (a_star);
CREATE TABLE c_star (
	c 			name
) INHERITS (a_star);
CREATE TABLE d_star (
	d 			float8
) INHERITS (b_star, c_star);
NOTICE:  merging multiple inherited definitions of column "class"
NOTICE:  merging multiple inherited definitions of column "a"
CREATE TABLE e_star (
	e 			int2
) INHERITS (c_star);
CREATE TABLE f_star (
	f 			polygon
) INHERITS (e_star);
CREATE TABLE aggtest (
	a 			int2,
	b			float4
);
CREATE TABLE hash_i4_heap (
	seqno 		int4,
	random 		int4
);
CREATE TABLE hash_name_heap (
	seqno 		int4,
	random 		name
);
CREATE TABLE hash_txt_heap (
	seqno 		int4,
	random 		text
);
CREATE TABLE hash_f8_heap (
	seqno		int4,
	random 		float8
);
-- don't include the hash_ovfl_heap stuff in the distribution
-- the data set is too large for what it's worth
--
-- CREATE TABLE hash_ovfl_heap (
--	x			int4,
--	y			int4
-- );
CREATE TABLE bt_i4_heap (
	seqno 		int4,
	random 		int4
);
CREATE TABLE bt_name_heap (
	seqno 		name,
	random 		int4
);
CREATE TABLE bt_txt_heap (
	seqno 		text,
	random 		int4
);
CREATE TABLE bt_f8_heap (
	seqno 		float8,
	random 		int4
);
CREATE TABLE array_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
CREATE TABLE testjsonb (
       j jsonb
);
CREATE TABLE IF NOT EXISTS test_tsvector(
	t text,
	a tsvector
);
CREATE TABLE IF NOT EXISTS test_tsvector(
	t text
);
NOTICE:  relation "test_tsvector" already exists, skipping
CREATE UNLOGGED TABLE unlogged1 (a int primary key);			-- OK
CREATE TEMPORARY TABLE unlogged2 (a int primary key);			-- OK
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
    relname     | relkind | relpersistence 
----------------+---------+----------------
 unlogged1      | r       | u
 unlogged1_pkey | i       | u
 unlogged2      | r       | t
 unlogged2_pkey | i       | t
(4 rows)

REINDEX INDEX unlogged1_pkey;
REINDEX INDEX unlogged2_pkey;
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
    relname     | relkind | relpersistence 
----------------+---------+----------------
 unlogged1      | r       | u
 unlogged1_pkey | i       | u
 unlogged2      | r       | t
 unlogged2_pkey | i       | t
(4 rows)

DROP TABLE unlogged2;
INSERT INTO unlogged1 VALUES (42);
CREATE UNLOGGED TABLE public.unlogged2 (a int primary key);		-- also OK
CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);	-- not OK
ERROR:  only temporary relations may be created in temporary schemas
LINE 1: CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);
                              ^
CREATE TABLE pg_temp.implicitly_temp (a int primary key);		-- OK
CREATE TEMP TABLE explicitly_temp (a int primary key);			-- also OK
CREATE TEMP TABLE pg_temp.doubly_temp (a int primary key);		-- also OK
CREATE TEMP TABLE public.temp_to_perm (a int primary key);		-- not OK
ERROR:  cannot create temporary relation in non-temporary schema
LINE 1: CREATE TEMP TABLE public.temp_to_perm (a int primary key);
                          ^
DROP TABLE unlogged1, public.unlogged2;
CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
ERROR:  relation "as_select1" already exists
CREATE TABLE IF NOT EXISTS as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
NOTICE:  relation "as_select1" already exists, skipping
DROP TABLE as_select1;
-- check that the oid column is added before the primary key is checked
CREATE TABLE oid_pk (f1 INT, PRIMARY KEY(oid)) WITH OIDS;
DROP TABLE oid_pk;
-- create partitioned table
CREATE TABLE person_partitioned (
	name text,
	age int
) PARTITION BY RANGE ON (age);
CREATE TABLE city_partitioned (
	name text
) PARTITION BY LIST ON (name);
DROP TABLE person_partitioned CASCADE;
DROP TABLE city_partitioned CASCADE;
-- cannot use system columns in partition key
CREATE TABLE fail_oid_pk (
	a int
) PARTITION BY RANGE ON (oid) WITH OIDS;	-- fail
ERROR:  cannot use system column "oid" in partition key
-- cannot use more than 1 column as partition key for list partitioned table
CREATE TABLE two_col_tab (
	a1 int,
	a2 int
) PARTITION BY LIST ON (a1, a2);	-- fail
ERROR:  cannot use more than one column in partition key
DETAIL:  Only one column allowed with list partitioning.
-- cannot use more than 16 columns as partition key for range partitioned table
CREATE TABLE wide_tab (
	a1 int,
	a2 int,
	a3 int,
	a4 int,
	a5 int,
	a6 int,
	a7 int,
	a8 int,
	a9 int,
	a10 int,
	a11 int,
	a12 int,
	a13 int,
	a14 int,
	a15 int,
	a16 int
) PARTITION BY RANGE ON (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);	-- ok
DROP TABLE wide_tab CASCADE;
-- not ok
CREATE TABLE extra_wide_tab (
	a1 int,
	a2 int,
	a3 int,
	a4 int,
	a5 int,
	a6 int,
	a7 int,
	a8 int,
	a9 int,
	a10 int,
	a11 int,
	a12 int,
	a13 int,
	a14 int,
	a15 int,
	a16 int,
	a17 int
) PARTITION BY RANGE ON (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);	-- fail
ERROR:  cannot use more than 16 columns in partition key
-- At the moment, partitioning requires to use columns with data type having
-- a suitable btree operator class
CREATE TABLE point_tab (a point) PARTITION BY LIST ON (a);		-- fail
ERROR:  data type point has no default btree operator class
HINT:  You must specify an existing btree operator class or define one for the data type.
CREATE TABLE point_tab (a point) PARTITION BY LIST ON (a USING point_ops);		-- fail
ERROR:  operator class "point_ops" does not exist for access method "btree"
CREATE TABLE point_tab (a point) PARTITION BY RANGE ON (a);		-- fail
ERROR:  data type point has no default btree operator class
HINT:  You must specify an existing btree operator class or define one for the data type.
CREATE TABLE point_tab (a point) PARTITION BY RANGE ON (a USING point_ops);		-- fail
ERROR:  operator class "point_ops" does not exist for access method "btree"
-- fail to create a partitioned table with PRIMARY KEY constraint
CREATE TABLE pk_fail (a int PRIMARY KEY) PARTITION BY RANGE ON (a);
ERROR:  primary key constraints are not supported on partitioned tables
LINE 1: CREATE TABLE pk_fail (a int PRIMARY KEY) PARTITION BY RANGE ...
                                    ^
-- fail to create a partitioned table with foreign key constraint
CREATE TABLE pk_rel(a int PRIMARY KEY);
CREATE TABLE pk_fail (a int REFERENCES pk_rel(a)) PARTITION BY RANGE ON (a);
ERROR:  foreign key constraints are not supported on partitioned tables
LINE 1: CREATE TABLE pk_fail (a int REFERENCES pk_rel(a)) PARTITION ...
                                    ^
DROP TABLE pk_rel;
-- fail to let a partitioned table be referenced in a foreign key
CREATE TABLE foo (a int) PARTITION BY RANGE ON (a);
CREATE TABLE bar_ref_foo (a int REFERENCES foo(a));
ERROR:  cannot reference relation "foo"
DETAIL:  Referencing partitioned tables in foreign key constraints is not supported.
DROP TABLE foo CASCADE;
-- fail to create a partitioned table with prohibited expressions in key
CREATE TABLE fail_const_key (a int) PARTITION BY RANGE ON (('a'));
ERROR:  cannot use a constant expression as partition key
CREATE TABLE fail_agg_in_key (a int) PARTITION BY RANGE ON ((avg(a)));
ERROR:  aggregate functions are not allowed in partition key expressions
CREATE TABLE fail_window_fun_in_key (a int, b int) PARTITION BY RANGE ON ((avg(a) OVER (PARTITION BY b)));
ERROR:  window functions are not allowed in partition key expressions
-- create partitioned table and partitions with invalid FOR VALUES
-- specification, for example, create a range partition with
-- FOR VALUES IN (...) specification
CREATE TABLE range_partitioned (
	a int
) PARTITION BY RANGE ON (a);
CREATE TABLE fail_partition
	PARTITION OF range_partitioned
	FOR VALUES IN (1, 2);		-- fail
ERROR:  invalid FOR VALUES specification for a range partition
DROP TABLE range_partitioned CASCADE;
CREATE TABLE list_partitioned (
	a int
) PARTITION BY LIST ON (a);
CREATE TABLE fail_partition
	PARTITION OF list_partitioned
	FOR VALUES LESS THAN (100);		-- fail
ERROR:  invalid FOR VALUES specification for a list partition
DROP TABLE list_partitioned CASCADE;
-- create range partitioned table and partitions
CREATE TABLE sales (
    tos timestamp NOT NULL,
    item text
) PARTITION BY RANGE ON (extract(year from tos), extract(month from tos));		-- ok
CREATE TABLE sales_before_2015
    PARTITION OF sales
    FOR VALUES LESS THAN (2015, 1);		-- ok
CREATE TABLE sales_2015_q1
    PARTITION OF sales
    FOR VALUES LESS THAN (2015, 4);		-- ok
-- effective partition range empty or overlapping
CREATE TABLE sales_2015_q2
	PARTITION OF sales
	FOR VALUES LESS THAN (2015, 4);	-- fail
ERROR:  cannot create range partition with empty range
HINT:  Please specify END value that is greater than max bound of the last partition
CREATE TABLE sales_2015_q2
	PARTITION OF sales
	FOR VALUES LESS THAN (2015, 3);	-- fail
ERROR:  cannot create range partition with range overlapping existing partitions
HINT:  Please specify END value that is greater than max bound of the last partition
-- more bound values than key columns
CREATE TABLE sales_2015_q2
    PARTITION OF sales
    FOR VALUES LESS THAN (2015, 3, 1);		-- fail
ERROR:  range partition FOR VALUES specification does not match the partition key
-- partitions are dependent on parent
DROP TABLE sales;		-- fail
ERROR:  cannot drop partitioned table sales because other objects depend on it
DETAIL:  partition sales_before_2015 depends on partitioned table sales
partition sales_2015_q1 depends on partitioned table sales
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP TABLE sales CASCADE;	-- ok
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to partition sales_before_2015
drop cascades to partition sales_2015_q1
-- create list partitioned table and partitions
CREATE TABLE store (
    id int,
    city text NOT NULL
) PARTITION BY LIST ON (city);
CREATE TABLE store_east
    PARTITION OF store
    FOR VALUES IN ('New York', 'Boston');	-- ok
CREATE TABLE store_west
    PARTITION OF store
    FOR VALUES ('San Fransisco', 'Seattle');	-- ok
-- overlap with some existing partition
CREATE TABLE store_ca
	PARTITION OF store
	FOR VALUES ('Los Angeles', 'San Fransisco');	-- fail
ERROR:  cannot create list partition that overlaps with an existing partition
DETAIL:  New partition's definition overlaps with partition "store_west".
DROP TABLE store CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to partition store_east
drop cascades to partition store_west
-- relpersistence of partitioned table and a partition
CREATE TEMP TABLE foo (
	a int
) PARTITION BY RANGE ON (a);
CREATE TEMP TABLE foo_1
	PARTITION OF foo
	FOR VALUES LESS THAN (100);		-- ok
-- cannot be non-temp partition of temp table
CREATE TABLE foo_2
	PARTITION OF foo
	FOR VALUES LESS THAN (100);		-- fail
ERROR:  cannot create a non-temporary partition of temporary table "foo"
DROP TABLE foo CASCADE;
NOTICE:  drop cascades to partition foo_1
CREATE UNLOGGED TABLE foo (
	a int
) PARTITION BY RANGE ON (a);
CREATE UNLOGGED TABLE foo_1
	PARTITION OF foo
	FOR VALUES LESS THAN (100);
-- cannot be logged/permanent partition of unlogged table
CREATE TABLE foo_2
	PARTITION OF foo
	FOR VALUES LESS THAN (100);		-- fail
ERROR:  cannot create a permanent partition of unlogged table "foo"
DROP TABLE foo CASCADE;
NOTICE:  drop cascades to partition foo_1
CREATE TABLE foo (
	a int
) PARTITION BY RANGE ON (a);
-- cannot be temp partition of non-temp table
CREATE TEMP TABLE foo_2
	PARTITION OF foo
	FOR VALUES LESS THAN (200);		-- fail
ERROR:  cannot create a temporary partition of non-temporary table
-- cannot be unlogged partition of permanent table
CREATE UNLOGGED TABLE foo_1
	PARTITION OF foo
	FOR VALUES LESS THAN (100);		-- fail
ERROR:  cannot create a unlogged partition of permanent table "foo"
DROP TABLE foo CASCADE;
